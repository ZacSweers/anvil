Fork Instructions
=================

This repo is a fork of Anvil that seeks to complete KSP support. At the point of divergence,
Anvil supported KSP contributions and factories, but not yet merging contributions or
contributing subcomponents.

## Blockers

Before trying to use KSP component merging, check this issue to see if any of the issues
listed there affect you: https://github.com/ZacSweers/anvil/issues/16.

## Installation

Right now, the easiest way to use this fork is to clone it and publish it to your local Maven.

```shell
git clone git@github.com:ZacSweers/anvil.git

cd anvil

# Change the VERSION_NAME in gradle.properties to a custom version, such as 2.6.0-local01

./gradlew publishToMavenLocal -x dokkaHtml --no-configuration-cache
```

Then consume this in your project.

```kotlin
// Change the anvil version in libs.versions.toml to the one you set in VERSION_NAME above

// In build.gradle/settings.gradle. Make sure you set this for both the buildscript and project repositories
repositories {
  // ...
  mavenLocal()
}
```

## Migration

### 0. Prerequisites

- You must be using Kotlin 1.9.24+ or 2.0.0+.
- You must use `-Xjvm-default=all` or `-Xjvm-default=all-compatibility` if you are not already.

### 1. KSP Contributions

It _should_ be possible to migrate to this fork with minimal source changes.

First, update to KSP contribution. It's better to do this first before proceeding to component
merging as it allows for incremental adoption. However, you can do both at the same time if you'd
rather. If you use `@ContributesSubcomponent` at all, you will need to do both steps 1 and 2 at the
same time as the legacy IR merger does not understand code generated by KSP subcomponent
contribution.

```kotlin
// In build.gradle
anvil {
  useKsp(
    contributesAndFactoryGeneration = true,
    componentMerging = false,
  )
}
```

This will use KSP for contributions (i.e. `@Contributes*` annotations) and factory generation.

Note that you may need to set up KAPT stub gen and KAPT to tasks to source KSP outputs for this. If
you are doing both steps at the same time, you can skip this.

Note that you also need to ensure that your kapt tasks still target Kotlin language version 1.9 for
this step as the original Anvil IR merger only works in Kotlin 1.9.

### 2. KSP Component Merging

Once you have KSP contributions working, you can enable component merging.

```kotlin
// In build.gradle
anvil {
  useKsp(
    contributesAndFactoryGeneration = true,
    componentMerging = true,
  )
}

```

Next - remove dagger-compiler from `kapt` configurations and move it to the `ksp` configuration
instead.

If this was the only bit using kapt, you can now remove kapt entirely! You can also remove
any `languageVersion` overrides forcing Kotlin 1.9.

This is where you will need to do some small source changes.

Replace any creator annotations with anvil equivalents.

| Before                  | After                        |
|-------------------------|------------------------------|
| `@Component.Factory`    | `@MergeComponent.Factory`    |
| `@Component.Builder`    | `@MergeComponent.Builder`    |
| `@Subcomponent.Factory` | `@MergeSubcomponent.Factory` |
| `@Subcomponent.Builder` | `@MergeSubcomponent.Builder` |

This is the only source change you should need to make! Anvil will generate source-compatible shims
where necessary for everything else.

You _should_ be able to build now.

## Compatibility

### Using Anvil KSP without dagger-ksp

It _should_ be possible to use Anvil KSP and still run dagger in kapt, but you will need to ensure
KSP's output sources are wired in as inputs to the appropriate kapt tasks. If you do this, you
_should_ be able to safely use K2 KAPT now and remove `languageVersion` overrides, as Anvil will not
longer be running a compiler plugin in kapt's stub gen task.

### Using Anvil KSP with KSP2

See the Blockers section for any issues here. At the time of writing, dagger-ksp does not work in
KSP2 but you may be able use Anvil KSP with KSP2 IFF you use dagger with kapt. YMMV.

### Backward compatibility

This fork should be backward-compatible with code generated from Anvil 2.5.0-beta09. However, it's
not well-tested and encouraged to recompile all Anvil-processed code after migrating to this fork.
Especially if you use `@ContributesSubcomponent` or `@MergeComponent`, as the generated code for
these scenarios has changed the most in the move to KSP.

## Areas to Pay Attention To

The following cases are the most complex and feedback on any issues or friction around them are
appreciated!

- `@ContributesSubcomponent`.
- `@MergeSubcomponent`
- `@MergeComponent`-annotated components that expose `@MergeSubcomponent`-annotated subcomponents
  directly. I.e. the below case, no creators.
  ```kotlin
  @MergeComponent(AppScope::class)
  interface AppComponent {
    fun loggedInComponent(): LoggedInComponent
  }
  
  @MergeSubcomponent(LoggedInScope::class)
  interface LoggedInComponent
  ```

## Future

In the medium term, I plan to tune the gradle plugin to be able to consume this in existing projects
easily and have the gradle plugin automatically replace dependencies with the fork's.

Long term, this will ideally move back upstream to Anvil main.

## Technical Design

In K1, Anvil contribution merging worked by _modifying_ the original component during IR
transformation.

This was convenient and allowed for a fairly simple implementation. However, this had two major
issues:

1. This is no longer possible in K2. We didn't learn of this until K2 testing, as the APIs we used
   in IR were not annotated as obsolete. This means that the original Anvil implementation is not
   compatible with K2.

  - Annotation generation in kapt stub generation still sort of works but is not recommended nor is
    it
    compatible with IC. The Kotlin compiler team advised migrating to a supported API in FIR
    instead.
  - Interface merging completely breaks in K2, as new interfaces added are quietly ignored. The
    Kotlin
    compiler team also declined to support such a case in the future.

2. This was not compatible with dagger-KSP, for various reasons.

  - In K1/KSP1, KSP never runs the IR backend, so Anvil never has a chance to perform merging.
  - In K2/KSP2, KSP never even runs a compiler plugin, so Anvil never has a chance to perform
    merging.

Rewriting the merging logic to run in KSP solves both of these issues, but required rethinking the
structure of generated code to work in a world where we cannot modify sources.

### "Merged" Classes

To solve this, we now generate a new class that acts as a "merged" version of the original
component. This class is more or less a source representation what the IR-transformed class would
have looked like in K1. From here, different things are done depending on the type of component and
if you're using dagger-ksp or kapt.

### Components

For components, we generate a new interface that extends the original component and includes all the
contributed modules and interfaces. This merged component is then what is processed by Dagger. If
running in kapt, kapt will just see this as any other source and process it as normal.

If running dagger-ksp, KSP's support for multiple rounds means that dagger's processor will see this
generated file in a subsequent round and process it then.

![ksp](docs/img_ksp_merging.png)

To ease adoption, we generate source-compatible shims for the original component name. I.e., you can
still write `DaggerAppComponent.factory()` like before, rather than needing to know about the new
`DaggerMergedAppComponent`.

### Subcomponents

Subcomponents largely work the same, but with small extra additions. Namely, they automatically
include a binding module that binds the `MergedExampleSubcomponent` to the original
`@ExampleSubcomponent` and expose a `ParentComponent` interface that exposes either its creator
factory or the subcomponent itself to consuming component classes. During component merging, Anvil
KSP automatically includes and implements these as needed.

`@ContributesSubcomponent` is implemented on top of this system.

### `@MergeModules`

These work largely the same as the above, except that the generated module obviously doesn't extend
the original module. Instead, Anvil KSP automatically includes the generated merged module when
including the original `@MergeModules`-annotated module.

**NOTE**: If you include a `@MergeModules`-annotated module in a non-anvil component, you must also
manually include the merged module in the component now.

### `@MergeInterfaces`

These also work the same as above. Similar to `@MergeModules`, these will automatically be included
by Anvil KSP when including the original `@MergeInterfaces`-annotated interface, but you will need
to manually include the merged interface in any components or interfaces that aren't processed by
Anvil KSP.

### A note about subcomponent factory methods

One special case that Anvil KSP has to support is a component that exposes a subcomponent factory
method (note: _not_ the subcomponent's `@Subcomponent.Factory` creator).

```kotlin
@MergeComponent(...)
interface AppComponent {
  fun userComponent(): UserComponent
}

@MergeSubcomponent(...)
interface UserComponent
```

In this case, Anvil KSP makes this system work by _implementing_ the `userComponent` function in the
merged component to just invoke the contributed subcomponent `ParentComponent` function. This is
also why Anvil KSP
requires `-Xjvm-default` to be set to `all` or `all-compatibility`, as it relies on Dagger's support
of
`default` methods.

```kotlin
// Generated by Anvil
@Component
interface MergedAppComponent : AppComponent, UserComponent.ParentComponent {
  // This is implemented to default to the contributed subcomponent's parent component
  override fun userComponent(): UserComponent = createUserComponent()
}

@Subcomponent
interface MergedUserComponent : UserComponent {
  interface ParentComponent {
    fun createUserComponent(): MergedUserComponent
  }
}
```
